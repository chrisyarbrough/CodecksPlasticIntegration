namespace Xarbrough.CodecksPlasticIntegration;

using Codice.Client.IssueTracker;

/// <summary>
/// A decorator that manages the error handling for extension calls,
/// because in some cases Plastic will display helpful information text
/// derived from uncaught exceptions, in other cases, an exception triggers
/// a potentially annoying popup for the user.
/// </summary>
/// <remarks>
/// This class is mostly boilerplate generated by the IDE,
/// but makes the important decisions which exceptions to hide from the user
/// and when to use them for helpful error reporting.
/// </remarks>
class ExtensionErrorHandling : IPlasticIssueTrackerExtension
{
	private readonly IPlasticIssueTrackerExtension extension;

	public ExtensionErrorHandling(IPlasticIssueTrackerExtension extension)
	{
		this.extension = extension;
	}

	public string GetExtensionName()
	{
		return extension.GetExtensionName();
	}

	public void Connect()
	{
		try
		{
			extension.Connect();
		}
		catch (Exception)
		{
			// A good reason to swallow the exception, is that the
			// connect call can be made in situations where the user
			// doesn't expect a login attempt to happen. For example,
			// when switching to a different workspace for which
			// credentials have not been set up yet.
		}
	}

	public void Disconnect()
	{
		extension.Disconnect();
	}

	public bool TestConnection(IssueTrackerConfiguration configuration)
	{
		// This may throw because of invalid credentials.
		// Pass it on for Plastic to display in a popup and the log handler to log.
		return extension.TestConnection(configuration);
	}

	public void LogCheckinResult(PlasticChangeset changeset, List<PlasticTask> tasks)
	{
		extension.LogCheckinResult(changeset, tasks);
	}

	public void UpdateLinkedTasksToChangeset(PlasticChangeset changeset, List<string> tasks)
	{
		extension.UpdateLinkedTasksToChangeset(changeset, tasks);
	}

	public PlasticTask GetTaskForBranch(string fullBranchName)
	{
		try
		{
			return extension.GetTaskForBranch(fullBranchName);
		}
		catch (Exception)
		{
			// This exception would open an annoying error popup every time
			// a user selects a branch.
			return null;
		}
	}

	public Dictionary<string, PlasticTask> GetTasksForBranches(List<string> fullBranchNames)
	{
		return extension.GetTasksForBranches(fullBranchNames);
	}

	public void OpenTaskExternally(string taskId)
	{
		extension.OpenTaskExternally(taskId);
	}

	public List<PlasticTask> LoadTasks(List<string> taskIds)
	{
		try
		{
			return extension.LoadTasks(taskIds);
		}
		catch (Exception)
		{
			// The request failed, most likely because the provided issue ID
			// does not match any card in Codecks.
			return new List<PlasticTask>();
		}
	}

	public List<PlasticTask> GetPendingTasks()
	{
		return extension.GetPendingTasks();
	}

	public List<PlasticTask> GetPendingTasks(string assignee)
	{
		return extension.GetPendingTasks(assignee);
	}

	public void MarkTaskAsOpen(string taskId, string assignee)
	{
		extension.MarkTaskAsOpen(taskId, assignee);
	}
}
